#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1
    bytecblock "listingOpen" "targetAmount" 0x151f7c75 "targetWallet" "receivedAmount" "/" "0" " microAlgos to " " microAlgos" "No listing is currently open"
    // smart_contracts/ch_ai_n/contract.algo.ts:3
    // export class ChAiN extends Contract {
    txn NumAppArgs
    bz main_bare_routing@10
    pushbytess 0x8aa38c11 0x62014ebf 0xd0bef942 0x7029cc0b 0x234db16b // method "openListing(string,string)string", method "processPayment(string,string)string", method "getListingStatus()string", method "closeListing()string", method "getListingDetails()string"
    txna ApplicationArgs 0
    match main_openListing_route@3 main_processPayment_route@4 main_getListingStatus_route@5 main_closeListing_route@6 main_getListingDetails_route@7

main_after_if_else@14:
    // smart_contracts/ch_ai_n/contract.algo.ts:3
    // export class ChAiN extends Contract {
    intc_0 // 0
    return

main_getListingDetails_route@7:
    // smart_contracts/ch_ai_n/contract.algo.ts:98
    // public getListingDetails(): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getListingDetails
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_closeListing_route@6:
    // smart_contracts/ch_ai_n/contract.algo.ts:86
    // public closeListing(): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub closeListing
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getListingStatus_route@5:
    // smart_contracts/ch_ai_n/contract.algo.ts:75
    // public getListingStatus(): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getListingStatus
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_processPayment_route@4:
    // smart_contracts/ch_ai_n/contract.algo.ts:40
    // public processPayment(sender: string, amount: string): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/ch_ai_n/contract.algo.ts:3
    // export class ChAiN extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/ch_ai_n/contract.algo.ts:40
    // public processPayment(sender: string, amount: string): string {
    callsub processPayment
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_openListing_route@3:
    // smart_contracts/ch_ai_n/contract.algo.ts:13
    // public openListing(targetWallet: string, targetAmount: string): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/ch_ai_n/contract.algo.ts:3
    // export class ChAiN extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/ch_ai_n/contract.algo.ts:13
    // public openListing(targetWallet: string, targetAmount: string): string {
    callsub openListing
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@10:
    // smart_contracts/ch_ai_n/contract.algo.ts:3
    // export class ChAiN extends Contract {
    txn OnCompletion
    bnz main_after_if_else@14
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts/ch_ai_n/contract.algo.ts::ChAiN.openListing(targetWallet: bytes, targetAmount: bytes) -> bytes:
openListing:
    // smart_contracts/ch_ai_n/contract.algo.ts:13
    // public openListing(targetWallet: string, targetAmount: string): string {
    proto 2 1
    // smart_contracts/ch_ai_n/contract.algo.ts:5
    // private listingOpen = GlobalState<boolean>({ key: 'listingOpen' })
    intc_0 // 0
    bytec_0 // "listingOpen"
    // smart_contracts/ch_ai_n/contract.algo.ts:15
    // if (this.listingOpen.hasValue && this.listingOpen.value) {
    app_global_get_ex
    bury 1
    bz openListing_after_if_else@3
    // smart_contracts/ch_ai_n/contract.algo.ts:5
    // private listingOpen = GlobalState<boolean>({ key: 'listingOpen' })
    intc_0 // 0
    bytec_0 // "listingOpen"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:15
    // if (this.listingOpen.hasValue && this.listingOpen.value) {
    bz openListing_after_if_else@3
    // smart_contracts/ch_ai_n/contract.algo.ts:16
    // return "Error: A listing is already open. Close it first."
    pushbytes "Error: A listing is already open. Close it first."
    retsub

openListing_after_if_else@3:
    // smart_contracts/ch_ai_n/contract.algo.ts:20
    // if (!targetWallet) {
    frame_dig -2
    len
    bnz openListing_after_if_else@5
    // smart_contracts/ch_ai_n/contract.algo.ts:21
    // return "Error: Target wallet cannot be empty"
    pushbytes "Error: Target wallet cannot be empty"
    retsub

openListing_after_if_else@5:
    // smart_contracts/ch_ai_n/contract.algo.ts:24
    // if (!targetAmount || targetAmount === "0") {
    frame_dig -1
    len
    bz openListing_if_body@7
    frame_dig -1
    bytec 6 // "0"
    ==
    bz openListing_after_if_else@8

openListing_if_body@7:
    // smart_contracts/ch_ai_n/contract.algo.ts:25
    // return "Error: Target amount must be greater than 0"
    pushbytes "Error: Target amount must be greater than 0"
    retsub

openListing_after_if_else@8:
    // smart_contracts/ch_ai_n/contract.algo.ts:5
    // private listingOpen = GlobalState<boolean>({ key: 'listingOpen' })
    bytec_0 // "listingOpen"
    // smart_contracts/ch_ai_n/contract.algo.ts:29
    // this.listingOpen.value = true
    intc_1 // 1
    app_global_put
    // smart_contracts/ch_ai_n/contract.algo.ts:6
    // private targetWallet = GlobalState<string>({ key: 'targetWallet' })
    bytec_3 // "targetWallet"
    // smart_contracts/ch_ai_n/contract.algo.ts:30
    // this.targetWallet.value = targetWallet
    frame_dig -2
    app_global_put
    // smart_contracts/ch_ai_n/contract.algo.ts:7
    // private targetAmount = GlobalState<string>({ key: 'targetAmount' })
    bytec_1 // "targetAmount"
    // smart_contracts/ch_ai_n/contract.algo.ts:31
    // this.targetAmount.value = targetAmount
    frame_dig -1
    app_global_put
    // smart_contracts/ch_ai_n/contract.algo.ts:8
    // private receivedAmount = GlobalState<string>({ key: 'receivedAmount' })
    bytec 4 // "receivedAmount"
    // smart_contracts/ch_ai_n/contract.algo.ts:32
    // this.receivedAmount.value = "0"
    bytec 6 // "0"
    app_global_put
    // smart_contracts/ch_ai_n/contract.algo.ts:34
    // return `Listing opened: ${targetAmount} microAlgos to ${targetWallet}`
    pushbytes "Listing opened: "
    frame_dig -1
    concat
    bytec 7 // " microAlgos to "
    concat
    frame_dig -2
    concat
    retsub


// smart_contracts/ch_ai_n/contract.algo.ts::ChAiN.processPayment(sender: bytes, amount: bytes) -> bytes:
processPayment:
    // smart_contracts/ch_ai_n/contract.algo.ts:40
    // public processPayment(sender: string, amount: string): string {
    proto 2 1
    // smart_contracts/ch_ai_n/contract.algo.ts:5
    // private listingOpen = GlobalState<boolean>({ key: 'listingOpen' })
    intc_0 // 0
    bytec_0 // "listingOpen"
    // smart_contracts/ch_ai_n/contract.algo.ts:42
    // if (!this.listingOpen.hasValue || !this.listingOpen.value) {
    app_global_get_ex
    bury 1
    bz processPayment_if_body@2
    // smart_contracts/ch_ai_n/contract.algo.ts:5
    // private listingOpen = GlobalState<boolean>({ key: 'listingOpen' })
    intc_0 // 0
    bytec_0 // "listingOpen"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:42
    // if (!this.listingOpen.hasValue || !this.listingOpen.value) {
    bnz processPayment_after_if_else@3

processPayment_if_body@2:
    // smart_contracts/ch_ai_n/contract.algo.ts:43
    // return "No active listing to process payment for"
    pushbytes "No active listing to process payment for"
    retsub

processPayment_after_if_else@3:
    // smart_contracts/ch_ai_n/contract.algo.ts:47
    // if (!sender) {
    frame_dig -2
    len
    bnz processPayment_after_if_else@5
    // smart_contracts/ch_ai_n/contract.algo.ts:48
    // return "Error: Sender cannot be empty"
    pushbytes "Error: Sender cannot be empty"
    retsub

processPayment_after_if_else@5:
    // smart_contracts/ch_ai_n/contract.algo.ts:51
    // if (!amount || amount === "0") {
    frame_dig -1
    len
    bz processPayment_if_body@7
    frame_dig -1
    bytec 6 // "0"
    ==
    bz processPayment_after_if_else@8

processPayment_if_body@7:
    // smart_contracts/ch_ai_n/contract.algo.ts:52
    // return "Error: Amount must be greater than 0"
    pushbytes "Error: Amount must be greater than 0"
    retsub

processPayment_after_if_else@8:
    // smart_contracts/ch_ai_n/contract.algo.ts:6
    // private targetWallet = GlobalState<string>({ key: 'targetWallet' })
    intc_0 // 0
    bytec_3 // "targetWallet"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:56
    // if (sender !== this.targetWallet.value) {
    frame_dig -2
    !=
    bz processPayment_after_if_else@10
    // smart_contracts/ch_ai_n/contract.algo.ts:57
    // return `Payment from ${sender} not to target wallet ${this.targetWallet.value}. Listing remains open.`
    pushbytes "Payment from "
    frame_dig -2
    concat
    pushbytes " not to target wallet "
    concat
    // smart_contracts/ch_ai_n/contract.algo.ts:6
    // private targetWallet = GlobalState<string>({ key: 'targetWallet' })
    intc_0 // 0
    bytec_3 // "targetWallet"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:57
    // return `Payment from ${sender} not to target wallet ${this.targetWallet.value}. Listing remains open.`
    concat
    pushbytes ". Listing remains open."
    concat
    retsub

processPayment_after_if_else@10:
    // smart_contracts/ch_ai_n/contract.algo.ts:8
    // private receivedAmount = GlobalState<string>({ key: 'receivedAmount' })
    bytec 4 // "receivedAmount"
    // smart_contracts/ch_ai_n/contract.algo.ts:61
    // this.receivedAmount.value = amount
    frame_dig -1
    app_global_put
    // smart_contracts/ch_ai_n/contract.algo.ts:7
    // private targetAmount = GlobalState<string>({ key: 'targetAmount' })
    intc_0 // 0
    bytec_1 // "targetAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:64
    // if (amount === this.targetAmount.value) {
    frame_dig -1
    ==
    bz processPayment_after_if_else@12
    // smart_contracts/ch_ai_n/contract.algo.ts:5
    // private listingOpen = GlobalState<boolean>({ key: 'listingOpen' })
    bytec_0 // "listingOpen"
    // smart_contracts/ch_ai_n/contract.algo.ts:65
    // this.listingOpen.value = false
    intc_0 // 0
    app_global_put
    // smart_contracts/ch_ai_n/contract.algo.ts:66
    // return `Listing closed! Target amount reached: ${amount}/${this.targetAmount.value} microAlgos`
    pushbytes "Listing closed! Target amount reached: "
    frame_dig -1
    concat
    bytec 5 // "/"
    concat
    // smart_contracts/ch_ai_n/contract.algo.ts:7
    // private targetAmount = GlobalState<string>({ key: 'targetAmount' })
    intc_0 // 0
    bytec_1 // "targetAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:66
    // return `Listing closed! Target amount reached: ${amount}/${this.targetAmount.value} microAlgos`
    concat
    bytec 8 // " microAlgos"
    concat
    retsub

processPayment_after_if_else@12:
    // smart_contracts/ch_ai_n/contract.algo.ts:69
    // return `Payment received: ${amount} microAlgos. Progress: ${amount}/${this.targetAmount.value}`
    pushbytes "Payment received: "
    frame_dig -1
    concat
    pushbytes " microAlgos. Progress: "
    concat
    frame_dig -1
    concat
    bytec 5 // "/"
    concat
    // smart_contracts/ch_ai_n/contract.algo.ts:7
    // private targetAmount = GlobalState<string>({ key: 'targetAmount' })
    intc_0 // 0
    bytec_1 // "targetAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:69
    // return `Payment received: ${amount} microAlgos. Progress: ${amount}/${this.targetAmount.value}`
    concat
    retsub


// smart_contracts/ch_ai_n/contract.algo.ts::ChAiN.getListingStatus() -> bytes:
getListingStatus:
    // smart_contracts/ch_ai_n/contract.algo.ts:5
    // private listingOpen = GlobalState<boolean>({ key: 'listingOpen' })
    intc_0 // 0
    bytec_0 // "listingOpen"
    // smart_contracts/ch_ai_n/contract.algo.ts:76
    // if (!this.listingOpen.hasValue || !this.listingOpen.value) {
    app_global_get_ex
    bury 1
    bz getListingStatus_if_body@2
    // smart_contracts/ch_ai_n/contract.algo.ts:5
    // private listingOpen = GlobalState<boolean>({ key: 'listingOpen' })
    intc_0 // 0
    bytec_0 // "listingOpen"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:76
    // if (!this.listingOpen.hasValue || !this.listingOpen.value) {
    bnz getListingStatus_after_if_else@3

getListingStatus_if_body@2:
    // smart_contracts/ch_ai_n/contract.algo.ts:77
    // return "No listing is currently open"
    bytec 9 // "No listing is currently open"
    retsub

getListingStatus_after_if_else@3:
    // smart_contracts/ch_ai_n/contract.algo.ts:8
    // private receivedAmount = GlobalState<string>({ key: 'receivedAmount' })
    intc_0 // 0
    bytec 4 // "receivedAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:80
    // return `Listing open: ${this.receivedAmount.value}/${this.targetAmount.value} microAlgos to ${this.targetWallet.value}`
    pushbytes "Listing open: "
    swap
    concat
    bytec 5 // "/"
    concat
    // smart_contracts/ch_ai_n/contract.algo.ts:7
    // private targetAmount = GlobalState<string>({ key: 'targetAmount' })
    intc_0 // 0
    bytec_1 // "targetAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:80
    // return `Listing open: ${this.receivedAmount.value}/${this.targetAmount.value} microAlgos to ${this.targetWallet.value}`
    concat
    bytec 7 // " microAlgos to "
    concat
    // smart_contracts/ch_ai_n/contract.algo.ts:6
    // private targetWallet = GlobalState<string>({ key: 'targetWallet' })
    intc_0 // 0
    bytec_3 // "targetWallet"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:80
    // return `Listing open: ${this.receivedAmount.value}/${this.targetAmount.value} microAlgos to ${this.targetWallet.value}`
    concat
    retsub


// smart_contracts/ch_ai_n/contract.algo.ts::ChAiN.closeListing() -> bytes:
closeListing:
    // smart_contracts/ch_ai_n/contract.algo.ts:5
    // private listingOpen = GlobalState<boolean>({ key: 'listingOpen' })
    intc_0 // 0
    bytec_0 // "listingOpen"
    // smart_contracts/ch_ai_n/contract.algo.ts:87
    // if (!this.listingOpen.hasValue || !this.listingOpen.value) {
    app_global_get_ex
    bury 1
    bz closeListing_if_body@2
    // smart_contracts/ch_ai_n/contract.algo.ts:5
    // private listingOpen = GlobalState<boolean>({ key: 'listingOpen' })
    intc_0 // 0
    bytec_0 // "listingOpen"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:87
    // if (!this.listingOpen.hasValue || !this.listingOpen.value) {
    bnz closeListing_after_if_else@3

closeListing_if_body@2:
    // smart_contracts/ch_ai_n/contract.algo.ts:88
    // return "No listing is currently open"
    bytec 9 // "No listing is currently open"
    retsub

closeListing_after_if_else@3:
    // smart_contracts/ch_ai_n/contract.algo.ts:5
    // private listingOpen = GlobalState<boolean>({ key: 'listingOpen' })
    bytec_0 // "listingOpen"
    // smart_contracts/ch_ai_n/contract.algo.ts:91
    // this.listingOpen.value = false
    intc_0 // 0
    app_global_put
    // smart_contracts/ch_ai_n/contract.algo.ts:8
    // private receivedAmount = GlobalState<string>({ key: 'receivedAmount' })
    intc_0 // 0
    bytec 4 // "receivedAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:92
    // return `Listing manually closed. Final amount received: ${this.receivedAmount.value}/${this.targetAmount.value} microAlgos`
    pushbytes "Listing manually closed. Final amount received: "
    swap
    concat
    bytec 5 // "/"
    concat
    // smart_contracts/ch_ai_n/contract.algo.ts:7
    // private targetAmount = GlobalState<string>({ key: 'targetAmount' })
    intc_0 // 0
    bytec_1 // "targetAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:92
    // return `Listing manually closed. Final amount received: ${this.receivedAmount.value}/${this.targetAmount.value} microAlgos`
    concat
    bytec 8 // " microAlgos"
    concat
    retsub


// smart_contracts/ch_ai_n/contract.algo.ts::ChAiN.getListingDetails() -> bytes:
getListingDetails:
    // smart_contracts/ch_ai_n/contract.algo.ts:5
    // private listingOpen = GlobalState<boolean>({ key: 'listingOpen' })
    intc_0 // 0
    bytec_0 // "listingOpen"
    // smart_contracts/ch_ai_n/contract.algo.ts:99
    // if (!this.listingOpen.hasValue || !this.listingOpen.value) {
    app_global_get_ex
    bury 1
    bz getListingDetails_if_body@2
    // smart_contracts/ch_ai_n/contract.algo.ts:5
    // private listingOpen = GlobalState<boolean>({ key: 'listingOpen' })
    intc_0 // 0
    bytec_0 // "listingOpen"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:99
    // if (!this.listingOpen.hasValue || !this.listingOpen.value) {
    bnz getListingDetails_after_if_else@3

getListingDetails_if_body@2:
    // smart_contracts/ch_ai_n/contract.algo.ts:100
    // return "No active listing"
    pushbytes "No active listing"
    retsub

getListingDetails_after_if_else@3:
    // smart_contracts/ch_ai_n/contract.algo.ts:7
    // private targetAmount = GlobalState<string>({ key: 'targetAmount' })
    intc_0 // 0
    bytec_1 // "targetAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:103
    // return `Target: ${this.targetAmount.value} microAlgos to ${this.targetWallet.value}, Received: ${this.receivedAmount.value} microAlgos`
    pushbytes "Target: "
    swap
    concat
    bytec 7 // " microAlgos to "
    concat
    // smart_contracts/ch_ai_n/contract.algo.ts:6
    // private targetWallet = GlobalState<string>({ key: 'targetWallet' })
    intc_0 // 0
    bytec_3 // "targetWallet"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:103
    // return `Target: ${this.targetAmount.value} microAlgos to ${this.targetWallet.value}, Received: ${this.receivedAmount.value} microAlgos`
    concat
    pushbytes ", Received: "
    concat
    // smart_contracts/ch_ai_n/contract.algo.ts:8
    // private receivedAmount = GlobalState<string>({ key: 'receivedAmount' })
    intc_0 // 0
    bytec 4 // "receivedAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/ch_ai_n/contract.algo.ts:103
    // return `Target: ${this.targetAmount.value} microAlgos to ${this.targetWallet.value}, Received: ${this.receivedAmount.value} microAlgos`
    concat
    bytec 8 // " microAlgos"
    concat
    retsub
